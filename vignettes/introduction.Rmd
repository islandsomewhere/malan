---
title: "Introduction"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Introduction}
  %\VignetteEncoding{UTF-8}
---

First, the library is loaded:
```{r}
library(malan)
```

For reproducibility, the seed for the (pseudo) random number generator is set:
```{r}
set.seed(1)
```

# Population simulation

Now, a population is simulated (hiding progress information):

```{r}
sim_res <- sample_geneology(population_size = 10L, generations = 10L, progress = FALSE)
```

## Building the pedigrees

Until pedigrees are build/infered, there is not much information available (e.g. about children). So let us infer the pedigrees:

```{r}
pedigrees <- build_pedigrees(sim_res$population, progress = FALSE)
pedigrees
pedigrees_count(pedigrees)
pedigrees_table(pedigrees)
pedigree_size(pedigrees[[1]])
pedigree_size(pedigrees[[2]])
#pedigree_size(pedigrees[[3L]]) # error as there are only 2 pedigrees
```

The pedigrees can be plotted all at once:

```{r}
plot(pedigrees)
```

Or just one at a time:
```{r}
plot(pedigrees[[1]])
```

```{r}
plot(pedigrees[[2]])
```

Some information about the population can be obtained. For example, the individuals in the final generation can be saved:
```{r}
str(sim_res, 1)
live_individuals <- sim_res$end_generation_individuals
```

And a live individual is printed:
```{r}
print_individual(live_individuals[[1]])
```

We can also print another individual (from the entire population):

```{r}
indv <- get_individual(sim_res$population, 22)
print_individual(indv)
```

## Run a mutation process

```{r}
set.seed(1)

mutrts <- c(0.5, 0.5)
pedigrees_all_populate_haplotypes(pedigrees = pedigrees, 
                                  loci = length(mutrts), 
                                  mutation_rates = mutrts, progress = FALSE)
```

Individual pedigrees can now be plotted with haplotype information:

```{r}
plot(pedigrees[[1]], haplotypes = TRUE)
```

And the individual id can be removed to only display the haplotype:

```{r}
plot(pedigrees[[1]], ids = FALSE, haplotypes = TRUE)
```


And one or more individuals can be marked/highlighted:

```{r}
plot(pedigrees[[1]], ids = TRUE, haplotypes = TRUE, mark_pids = c(14, 22))
```


## More than 1 full generation

By standard, only the last generation contains $N$ individuals. If the last 3 generations should be full, this can be done by specifying `extra_generations_full = 2` as follows (2 extra as the last generation always has $N$ individuals):

```{r}
set.seed(1)
sim_res <- sample_geneology(population_size = 10, 
                            generations = 5, 
                            extra_generations_full = 2,
                            progress = FALSE)
pedigrees <- build_pedigrees(sim_res$population, progress = FALSE)
plot(pedigrees)
```

## Simulate to one founder

By standard, the number of generations are specified. Instead, it can be specified to continue simulating until one common founder is reached by specifying `generations = -1`:

```{r}
set.seed(1)
sim_res <- sample_geneology(population_size = 10, 
                            generations = -1, 
                            progress = FALSE)
pedigrees <- build_pedigrees(sim_res$population, progress = FALSE)
plot(pedigrees)
```

The number of generations needed can be obtained as follows:

```{r}
sim_res$generations
```

# Counting matches

## Simulating the population

Let's try to simulate a larger population with 3 full generations (the additional `individuals_generations_return` is to get all individuals in the last 3 generations returned in the `individuals_generations` slot, cf. below, and the default value is 2 but is included here for demonstration purposes):

```{r}
set.seed(1)
sim_res <- sample_geneology(population_size = 1e3, 
                            generations = 100, 
                            extra_generations_full = 2,
                            individuals_generations_return = 2, # default value
                            progress = FALSE)
```

And build the pedigrees:
```{r}
pedigrees <- build_pedigrees(sim_res$population, progress = FALSE)
pedigrees_table(pedigrees)
pedigrees_count(pedigrees)
```

So there are `r pedigrees_count(pedigrees)` pedigrees. Let's try to plot the largest one:

```{r}
ped_sizes <- sapply(1L:pedigrees_count(pedigrees), function(i) pedigree_size(pedigrees[[i]]))
ped_sizes
largest_i <- which.max(ped_sizes)
plot(pedigrees[[largest_i]])
```

And the impose mutations from a 20 locus haplotype with mutation rate 0.001 per locus:

```{r}
set.seed(10)
mutrts <- rep(0.001, 20)
pedigrees_all_populate_haplotypes(pedigrees = pedigrees, 
                                  loci = length(mutrts), 
                                  mutation_rates = mutrts, progress = FALSE)
```

The haplotypes at the live individuals (3 generations) can be inspected:

```{r}
live_individuals <- sim_res$individuals_generations
length(live_individuals)
```

```{r}
haps <- individuals_get_haplotypes(individuals = live_individuals)
```

```{r}
head(haps)
```

Lets look at the spectrum:
```{r}
haps_str <- apply(haps, 1, paste0, collapse = ";")
haps_tab <- table(haps_str)
sort(haps_tab, decreasing = TRUE)[1:10]
spectrum <- table(haps_tab)
spectrum
```

## Drawing an individual and counting matches

```{r}
set.seed(100)
Q_index <- sample.int(n = length(live_individuals), size = 1)
Q <- live_individuals[[Q_index]]
Q_hap <- get_haplotype(Q)
Q_hap
```

First, identify $Q$'s pedigree:

```{r}
Q_ped <- get_pedigree_from_individual(Q)
```

Now, count matches in pedigree and in live population:

```{r}
count_haplotype_occurrences_pedigree(pedigree = Q_ped, haplotype = Q_hap, generation_upper_bound_in_result = 2)
count_haplotype_occurrences_individuals(individuals = live_individuals, haplotype = Q_hap)
```

We can also inspect pedigree matches information about number of meioses and $L_1$ distances:

```{r}
path_details <- pedigree_haplotype_matches_in_pedigree_meiosis_L1_dists(suspect = Q, 
                                                                        generation_upper_bound_in_result = 2)
```

```{r}
nrow(path_details)
head(path_details)
```

Look at the distribution of number of meioses between $Q$ and the matches (there are 0 meioses between Q and himself):
```{r}
meioses <- path_details[, 1]
hist(meioses)
```

On the path between $Q$ and the match, the maximum $L_1$ difference between $Q$'s haplotype and the haplotypes of the individuals on the path is recorded (0 means that that no mutations have occured on the path between $Q$ and the match):

```{r}
L1_max <- path_details[, 2]
table(L1_max)
mean(L1_max == 0)
```



# Other functions

[To appear...]

## Variance in number of children

[To appear...]

## Mixtures


[To appear...]